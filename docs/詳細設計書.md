# ローカル パイプラインエンジン 設計書 v0.2

## 0. コンセプト

### 名称（仮）： Pipeline Engine

ローカルマシン上で常駐／組み込みのどちらでも利用できる、汎用 AI パイプライン実行エンジン。

- **入力**: ログ／コード／ノート／テキスト／JSON など
- **処理**: 複数の AI ノード（OpenAI / Ollama / 画像生成 / ローカルツールなど）を直列・並列・fanout でつないだ パイプライン(DAG) を実行
- **出力**: 各ノードの「最終結果（ResultItem）」をストリーミング＋最終集約結果として返す。

### 前提ポリシー

- エンジンは監視・スケジューラ機能を持たない
- アプリケーション側がログ監視・ファイル監視・定期実行を担う
- エンジンは「ジョブリクエストを受けてパイプラインを実行するだけ」の受動的な実行コンポーネント
- ストリーミングはUX用の“途中経過”
- 接続が途切れてもジョブは裏で継続する
- 各ノードの「最終結果」は `GET /v1/jobs/{id}` で取得可能
- ストリーム自体の「途中から再開」は v0 では行わない（ベストエフォート）
- 各ノードごとにプロンプト指示を持つ
- `StepDef` に構造化された `PromptTemplate` を持たせる
- 実行中ジョブはAPIから中断（キャンセル）可能
- ジョブ全体をキャンセルする `/v1/jobs/{id}/cancel` を提供する

## 1. ゴールとフェーズ

### 1.1 フェーズ1：エンジン＆SDK

#### 第一ゴール：
- 汎用のパイプライン実行エンジン
- DAGベースのパイプライン
- Provider抽象（OpenAI / Ollama / Image / LocalTool）
- コンテンツタイプ (text / markdown / json / image / embedding …)
- ノードごとの構造化プロンプト（PromptTemplate）
- 実行状態管理（Job / StepExecution / StepCheckpoint）
- リラン（途中から再実行）
- 実行中キャンセル
- 呼び出しライブラリ（SDK）
  - TypeScript / Node（Electron / Webバックエンド）
  - Python（FastAPIなど）
  - Go（同一プロセス組み込み）

### 1.2 フェーズ2：アプリケーション

- 常駐サジェスタアプリ
- フローベースUI（ノードを線で繋ぐ Web/Electron アプリ）
- CLI / エディタ連携ツール
- 思考ノート / 音声書き起こし分析など

これらはすべてエンジン＋SDK＋パイプライン定義を組み合わせて実現する。

## 2. アーキテクチャ概要

### 2.1 コンポーネント

- **Engine Core（Go）**
  - パイプライン定義管理
  - パイプライン実行（DAGスケジューラ）
  - Provider実行（OpenAI/Ollama/Image/LocalTool）
  - PromptTemplate適用
  - Job / StepExecution / StepCheckpoint の管理
  - キャンセル・リランの処理

- **HTTP サーバー（Go）**
  - Unixソケット / 127.0.0.1 で待ち受け
  - REST + NDJSON ストリーミング
  - Engine Core を薄くラップするレイヤ

- **SDK / クライアント**
  - TypeScript / Node
  - Python
  - Go

### 2.2 通信

- **トランスポート**
  - 推奨：Unixドメインソケット (/run/pipeline-engine.sock など)
  - 代替：http://127.0.0.1:8085 などのローカルTCP

- **プロトコル**
  - HTTP/1.1 + JSON
  - ストリーミング：application/x-ndjson（1行1イベント）

## 3. ドメインモデル

### 3.1 Provider

```go
type ProviderKind string

const (
    ProviderOpenAI ProviderKind = "openai"
    ProviderOllama ProviderKind = "ollama"
    ProviderImage  ProviderKind = "image"
    ProviderLocal  ProviderKind = "local_tool"
)

type ProviderProfileID string

type ProviderProfile struct {
    ID           ProviderProfileID `json:"id"`
    Kind         ProviderKind      `json:"kind"`
    BaseURI      string            `json:"base_uri"`
    APIKey       string            `json:"api_key,omitempty"`
    DefaultModel string            `json:"default_model,omitempty"`
    Extra        map[string]any    `json:"extra,omitempty"`
}

type EngineConfig struct {
    Providers []ProviderProfile `json:"providers"`
}
```

#### StepDef 側での上書き

```go
type StepDef struct {
    ProviderProfileID ProviderProfileID `json:"provider_profile_id"`
    ProviderOverride  map[string]any    `json:"provider_override,omitempty"`
}
```

#### 解決優先度

1. Step の ProviderOverride
2. ProviderProfile
3. エンジンのグローバルデフォルト（あれば）

### 3.2 コンテンツ & プロンプト

```go
type ContentType string

const (
    ContentText      ContentType = "text"
    ContentMarkdown  ContentType = "markdown"
    ContentJSON      ContentType = "json"
    ContentImage     ContentType = "image"
    ContentEmbedding ContentType = "embedding"
    ContentTable     ContentType = "table"
    ContentBinary    ContentType = "binary"
)

type OutputFormat string

const (
    OutputFormatText       OutputFormat = "text"
    OutputFormatJSONStrict OutputFormat = "json_strict"
    OutputFormatJSONLoose  OutputFormat = "json_loose"
)

type PromptTemplate struct {
    System string `json:"system,omitempty"`
    User   string `json:"user,omitempty"`
    Meta   map[string]any `json:"meta,omitempty"`
}
```

### 3.3 パイプライン定義

```go
type PipelineType string

type StepKind string

const (
    StepKindLLM    StepKind = "llm"
    StepKindImage  StepKind = "image"
    StepKindMap    StepKind = "map"
    StepKindReduce StepKind = "reduce"
    StepKindCustom StepKind = "custom"
)

type StepMode string

const (
    StepModeSingle  StepMode = "single"
    StepModeFanOut  StepMode = "fanout"
    StepModePerItem StepMode = "per_item"
)

type StepDef struct {
    ID        StepID      `json:"id"`
    Name      string      `json:"name"`
    Kind      StepKind    `json:"kind"`
    Mode      StepMode    `json:"mode,omitempty"`
    DependsOn []StepID    `json:"depends_on"`
    ProviderProfileID ProviderProfileID `json:"provider_profile_id"`
    ProviderOverride  map[string]any    `json:"provider_override,omitempty"`
    Prompt *PromptTemplate `json:"prompt,omitempty"`
    OutputType   ContentType  `json:"output_type"`
    OutputFormat OutputFormat `json:"output_format,omitempty"`
    Config map[string]any `json:"config,omitempty"`
    Export    bool   `json:"export,omitempty"`
    ExportTag string `json:"export_tag,omitempty"`
}

type PipelineDef struct {
    Type     PipelineType `json:"type"`
    Version  string       `json:"version"`
    Steps    []StepDef    `json:"steps"`
}
```

### 3.4 Job 入力・結果

```go
type JobStatus string

const (
    JobStatusQueued    JobStatus = "queued"
    JobStatusRunning   JobStatus = "running"
    JobStatusSucceeded JobStatus = "succeeded"
    JobStatusFailed    JobStatus = "failed"
    JobStatusCancelled JobStatus = "cancelled"
)

type SourceKind string

const (
    SourceKindLog  SourceKind = "log"
    SourceKindCode SourceKind = "code"
    SourceKindNote SourceKind = "note"
    SourceKindRaw  SourceKind = "raw"
)

type Source struct {
    Kind     SourceKind     `json:"kind"`
    Label    string         `json:"label"`
    Content  string         `json:"content"`
    Metadata map[string]any `json:"metadata,omitempty"`
}

type JobInput struct {
    Sources []Source    `json:"sources"`
    Options *JobOptions `json:"options,omitempty"`
}

type ResultItem struct {
    ID        string      `json:"id"`
    Label     string      `json:"label"`
    StepID    StepID      `json:"step_id"`
    ShardKey  *string     `json:"shard_key,omitempty"`
    IsPrimary bool        `json:"is_primary,omitempty"`
    Kind      string      `json:"kind"`
    Tag       string      `json:"tag,omitempty"`
    ContentType ContentType `json:"content_type"`
    Data      any         `json:"data"`
}

type JobResult struct {
    Items []ResultItem   `json:"items"`
    Meta  map[string]any `json:"meta,omitempty"`
}

type Job struct {
    ID              string       `json:"id"`
    PipelineType    PipelineType `json:"pipeline_type"`
    PipelineVersion string       `json:"pipeline_version"`
    Status          JobStatus    `json:"status"`
    CreatedAt       time.Time    `json:"created_at"`
    UpdatedAt       time.Time    `json:"updated_at"`
    Input           JobInput     `json:"input"`
    Result          *JobResult   `json:"result,omitempty"`
    Error           *JobError    `json:"error,omitempty"`
    StepExecutions  []StepExecution `json:"step_executions,omitempty"`
    ParentJobID     *string      `json:"parent_job_id,omitempty"`
    Mode            string       `json:"mode,omitempty"`
}
```

### 3.5 エラー / StepExecution / StepCheckpoint

```go
type JobError struct {
    Code    string      `json:"code"`
    Message string      `json:"message"`
    Details interface{} `json:"details,omitempty"`
}

type StepExecutionStatus string

const (
    StepExecPending   StepExecutionStatus = "pending"
    StepExecRunning   StepExecutionStatus = "running"
    StepExecSuccess   StepExecutionStatus = "success"
    StepExecFailed    StepExecutionStatus = "failed"
    StepExecSkipped   StepExecutionStatus = "skipped"
    StepExecCancelled StepExecutionStatus = "cancelled"
)

type StepExecution struct {
    StepID     StepID              `json:"step_id"`
    Status     StepExecutionStatus  `json:"status"`
    StartedAt  *time.Time           `json:"started_at,omitempty"`
    FinishedAt *time.Time           `json:"finished_at,omitempty"`
    Error      *JobError            `json:"error,omitempty"`
}

type StepCheckpoint struct {
    JobID    string     `json:"job_id"`
    StepID   StepID     `json:"step_id"`
    ShardKey *string    `json:"shard_key,omitempty"`
    Result   ResultItem `json:"result"`
}
```

ストリーミング中のトークン列は保存せず、各 Step の「最終 ResultItem」だけをチェックポイントとして保存。rerun 時に from_step_id より前のステップの結果を再利用する。

## 4. ストリーミングポリシー

### 4.1 方針

- ストリーミングは途中経過の視覚化用
- 接続が切れてもジョブは続行
- クライアントはストリームが切れたら `GET /v1/jobs/{id}` をポーリング or 再取得
- ストリーム再開（resume）は v0 では行わない

### 4.2 StreamingEvent

```go
type StreamingEvent struct {
    Event string      `json:"event"`
    JobID string      `json:"job_id"`
    Data  interface{} `json:"data"`
}
```

主なイベント：
- job_started
- job_completed
- job_failed
- job_cancelled
- item_started
- item_token
- item_progress
- item_completed

## 5. HTTP API

### ベースURL例：http://127.0.0.1:8085

### 5.1 Health

```http
GET /health

{
  "status": "ok",
  "version": "0.2.0",
  "uptime_sec": 1234
}
```

### 5.2 ジョブ作成

```http
POST /v1/jobs

Request
{
  "pipeline_type": "system_log_analysis",
  "input": {
    "sources": [
      {
        "kind": "log",
        "label": "journalctl",
        "content": "11月 17 14:44:55 ...",
        "metadata": { "filename": "journalctl.txt" }
      }
    ],
    "options": {
      "max_tokens": 2048,
      "detail_level": "normal",
      "language": "ja"
    }
  },
  "mode": "sync"   // "sync" | "async"
}
```

#### Response (async)

```http
202 Accepted

{
  "job": {
    "id": "job_...",
    "pipeline_type": "system_log_analysis",
    "pipeline_version": "v0.2.0",
    "status": "queued",
    "created_at": "...",
    "updated_at": "...",
    "result": null,
    "error": null
  }
}
```

#### Response (sync)

```http
200 OK
```

### 5.3 ジョブ取得

```http
GET /v1/jobs/{job_id}

{
  "job": {
    "id": "job_...",
    "pipeline_type": "system_log_analysis",
    "pipeline_version": "v0.2.0",
    "status": "running",
    "created_at": "...",
    "updated_at": "...",
    "result": null,
    "error": null,
    "step_executions": [
      { "step_id": "parse_logs", "status": "success", "started_at": "...", "finished_at": "..." },
      { "step_id": "llm_summary", "status": "running", "started_at": "...", "finished_at": null }
    ]
  }
}
```

### 5.4 ストリーム

```http
GET /v1/jobs/{job_id}/stream
Content-Type: application/x-ndjson
```

`POST /v1/jobs?stream=true` も同じ形式。接続が切れてもジョブは継続する。送出する主なイベント例は下記のとおり（すべて `{ "event": "...", "job_id": "...", "data": ... }` フォーマット）。

| event                | 説明 |
| -------------------- | ---- |
| `job_status`         | ジョブ全体の状態変化（queued / running / succeeded / failed / cancelled）|
| `job_started`        | queued → running の遷移時に一度だけ送出 |
| `job_completed`      | 成功時。失敗・キャンセル時は `job_failed` / `job_cancelled` |
| `step_started`       | StepExecution が running になった瞬間 |
| `step_completed`     | StepExecution が success になった瞬間（失敗・キャンセル時は `step_failed` / `step_cancelled`）|
| `item_completed`     | `Export=true` の ResultItem を JobResult へ追加した際に送出 |
| `provider_chunk`     | Provider から届いた chunk (`StepChunk`) を逐次送出 |
| `stream_finished`    | ストリーム終端を通知。以降イベントは送出されない |
| `error`              | ストリーミング取得中にサーバーでエラーが発生した場合 |

### 5.5 ワンショットストリーム

```http
POST /v1/suggest/stream
```

`/v1/jobs (async) + /v1/jobs/{id}/stream` のショートカット。

### 5.6 リラン（途中から再実行）

```http
POST /v1/jobs/{job_id}/rerun

Request
{
  "from_step_id": "llm_suggestions",
  "reuse_upstream": true,
  "override_input": {
    "sources": [...],
    "options": { ... }
  }
}
```

#### 挙動

- `from_step_id` より前の Step：
  - `reuse_upstream: true` → StepCheckpoint を再利用（実行スキップ）
  - `false` → すべて再実行
- `from_step_id` 以降の Step を再実行
- 新しい Job を作成（`parent_job_id = {job_id}`, `mode = "rerun"`）
- `override_input` が指定されていれば親ジョブの `Input` を置き換える

### 5.7 キャンセル（実行中ジョブの中断）

```http
POST /v1/jobs/{job_id}/cancel

Request
{
  "reason": "user_requested"   // 任意。null でも可
}
```

#### 挙動

- queued or running 状態のジョブのみキャンセル対象
- Engine は Job の Status を cancelled に変更
- 実行中 Step に対して context cancel / interrupt を投げる
- ストリーミング中であれば job_cancelled イベントを最後に流す。

#### Response

```http
200 OK

{
  "job": {
    "id": "job_...",
    "status": "cancelled",
    "step_executions": [
      // ステップごとの最終状態
    ]
  }
}
```

### 5.8 エラー共通形式

```json
{
  "error": {
    "code": "invalid_request",
    "message": "pipeline_type is required",
    "details": null
  }
}
```

## 6. 内部エンジン（ざっくり）

### 6.1 Engine インターフェース

```go
type JobRequest struct {
    PipelineType PipelineType `json:"pipeline_type"`
    Input        JobInput     `json:"input"`
    Mode         string       `json:"mode,omitempty"`
}

type Engine interface {
    RunJob(ctx context.Context, req JobRequest) (*Job, error)
    RunJobStream(ctx context.Context, req JobRequest) (<-chan StreamingEvent, *Job, error)
    CancelJob(jobID string, reason string) error
}
```

### 6.2 DAG スケジューラ概要

- PipelineDef.Steps を依存関係付きDAGとして解釈
- DependsOn が空の Step から開始
- Mode により：
  - single：1回実行
  - fanout：シャード（リスト）を生成
  - per_item：fanout結果ごとに並列実行
- Export=true の Step の最終結果は JobResult.items に保存。

### 6.3 PromptTemplate の適用

- Engine は Step の PromptTemplate に入力コンテキストをバインド
- Provider実装（例：OpenAI / Ollama）が PromptTemplate を各プロバイダ固有の Request 形式に変換。

## 7. パイプライン例（抜粋）

（前回と同様の system_log_analysis / system_log_by_service でOK。PromptTemplate を使う場合は llm_summary / service_analysis Step に prompt を追加するイメージ。）

## 8. 今後の拡張

- ストリーム再開 (after_seq 付き /stream)
- パイプライン定義のホットリロード
- StepCheckpoint の永続化ストア差し替え
- 認証（ローカルAPIキー）
- フローエディタと NodeBinding:
  - ノードごとに PromptTemplate / ProviderProfile を設定
  - リザルトは StepID / item_id 単位でバインド
### 5.7 オブザーバビリティ
- ログレベルは `PIPELINE_ENGINE_LOG_LEVEL`（`debug`/`info`/`warn`/`error`）で制御し、Provider 呼び出し開始/終了や chunk 送出を DEBUG で確認できる。
- `expvar` を利用し `/debug/vars` に以下のメトリクスを公開：
  - `provider_call_count`, `provider_call_latency_ms`, `provider_call_errors` （provider kind 別）
  - `provider_chunk_count`（chunk 送出数）
- chunk は `StepExecution.chunks` に保存され、`provider_chunk` イベントとしてストリーム経由でクライアントへ配信される。
### 5.8 Provider 設定 API

```
POST /v1/config/providers
Content-Type: application/json

{
  "id": "openai-cli",
  "kind": "openai",
  "base_uri": "https://api.openai.com/v1",
  "api_key": "...",
  "default_model": "gpt-4o-mini",
  "extra": {"system_prompt": "..."}
}
```

エンジンの `ProviderRegistry` に対してプロファイルを upsert する簡易エンドポイント。Electron などのクライアントから API キーを差し替える用途を想定。
### 5.9 Engine 設定 API

```
POST /v1/config/engine
{
  "log_level": "debug"
}
```

ログレベル等のエンジン設定をランタイムで変更する簡易エンドポイント。`logging.SetLevelFromString` を呼び出し、呼び出し結果を返却する。
